---
description: debug，fixbug，修复，
globs: 
alwaysApply: false
---
# 通用 Debugging 规范 (General Debugging Specification)

本规范旨在提供一套系统化的方法来诊断和解决代码中的 Bug，提高 Debugging 效率和准确性，并促进代码质量的长期提升。

测试执行：AI
## 1. 复现与隔离 (Reproduction & Isolation)

**目标:** 稳定地重现问题，并将其范围缩小到最小的可疑区域。

*   **1.1. 稳定复现 (Reliable Reproduction):**
    *   确保你能在本地或其他可控环境中**稳定地、按需地**重现 Bug。
    *   记录精确的复现步骤、触发条件、输入数据和环境配置（软件版本、操作系统等）。
    *   如果 Bug 是间歇性的，尝试找出可能影响其出现的因素（时间、负载、特定数据、并发等），增加复现概率。
*   **1.2. 最小化复现用例 (Minimal Failing Example):**
    *   创建一个尽可能简单的代码片段或测试用例，它仍然能触发这个 Bug，但移除了所有不相关的代码和依赖。
    *   这有助于将问题隔离到核心逻辑，并方便后续分析和分享。
*   **1.3. 隔离问题范围 (Isolate the Scope):**
    *   **二分定位 (Bisecting):**
        *   **代码层面:** 如果不确定 Bug 在哪次提交引入，使用 `git bisect` 定位引入问题的 commit。
        *   **逻辑层面:** 在代码执行路径中添加检查点或日志，逐步缩小 Bug 可能发生的范围（例如，确认函数 A 的输出是否符合预期，再检查函数 B）。
        *   **数据层面:** 如果问题与特定输入相关，尝试简化输入数据，找出导致问题的最小数据特征。
    *   **依赖隔离:** 暂时移除或 Mock/Stub 掉外部依赖（数据库、网络 API、第三方库），判断问题是否出在自身代码逻辑中。

## 2. 观察与分析 (Observation & Analysis)

**目标:** 收集关于 Bug 行为的详细信息，理解实际发生了什么。

*   **2.1. 仔细阅读错误信息 (Read Error Messages Carefully):**
    *   完整阅读错误消息和完整的调用栈 (Traceback)。
    *   理解每一层调用栈的含义，确定错误的直接来源。
    *   注意错误类型（`TypeError`, `ValueError`, `KeyError` 等），它提供了关于问题性质的重要线索。
*   **2.2. 战略性日志/打印 (Strategic Logging/Printing):**
    *   在关键代码路径、条件分支、循环内部、函数入口/出口添加临时的 `print()` 或 Debug 级别的日志。
    *   输出关键变量的值、对象类型 (`type()`)、对象 ID (`id()`)，以验证程序状态是否符合预期。
    *   **注意:** 添加日志后需重新运行复现步骤。完成后记得清理临时日志。
*   **2.3. 使用调试器 (Use a Debugger):**
    *   对于复杂的逻辑或难以通过日志追踪的状态变化，使用调试器（如 `pdb`, `ipdb`, IDE 集成调试器）。
    *   设置断点，单步执行代码（Step Over, Step Into, Step Out）。
    *   检查变量值，查看调用栈，理解程序运行时的精确状态。
*   **2.4. 检查外部状态和环境 (Check External State & Environment):**
    *   确认数据库中的数据是否符合预期。
    *   检查外部 API 的响应是否正确，或其服务是否可用。
    *   确认文件系统权限、网络连接、环境变量等是否正确配置。
    *   确认所依赖库的版本是否与预期一致。
*   **2.5. 代码审查与逻辑梳理 (Code Review & Logic Analysis):**
    *   **通读相关代码:** 仔细阅读与 Bug 相关的代码段，尝试理解其设计意图和逻辑流程。
    *   **质疑假设:** 挑战自己对代码行为、库函数行为或系统状态的假设，它们可能与实际情况不符。
    *   **文档查阅:** 查阅相关函数、库或 API 的官方文档，确认使用方式是否正确，是否有未注意到的边界情况或副作用。
    *   **搜索已知问题:** 使用错误信息或关键代码片段在搜索引擎、Stack Overflow 或项目的 Issue Tracker 中搜索，看是否是已知问题。

## 3. 假设与验证 (Hypothesis & Validation)

**目标:** 基于观察提出关于 Bug 原因的假设，并通过实验验证。

*   **3.1. 形成具体假设 (Formulate Specific Hypotheses):**
    *   根据观察到的现象和分析，提出一个或多个关于 Bug 根本原因的具体、可测试的假设（例如：“变量 X 在循环的第 N 次迭代中变成了 None”，“对库函数 Y 的调用返回了非预期的 Z”）。
*   **3.2. 一次只改一件事 (Change One Thing at a Time):**
    *   为了验证某个假设，只修改与该假设直接相关的代码或配置。
    *   避免一次性应用多个可能的修复，否则无法确定哪个改动真正解决了问题。
*   **3.3. 设计实验验证 (Design Experiments to Validate):**
    *   基于假设，预测如果修改某部分代码或输入，Bug 应该如何变化（消失、改变表现形式等）。
    *   通过运行修改后的代码或测试来验证预测。
    *   如果实验结果与预测不符，修正或放弃该假设，形成新的假设。

## 4. 修复与确认 (Fixing & Confirmation)

**目标:** 应用正确的修复，并确保修复有效且没有引入新问题。

*   **4.1. 应用最小化修复 (Apply Minimal Fix):**
    *   实施能解决 Bug 根本原因的、尽可能小的代码改动。
    *   理解**为什么**这个修复是有效的。避免仅仅是“凑巧能用”的修复。
*   **4.2. 编写回归测试 (Write Regression Test):**
    *   **强烈推荐:** 在应用修复之前（或之后立即），编写一个单元测试或集成测试，该测试专门复现你刚刚修复的那个 Bug。
    *   确认这个测试在修复前是失败的，在修复后能通过。
    *   这个测试将防止同样的 Bug 在未来再次出现（回归）。
*   **4.3. 全面测试验证 (Comprehensive Testing):**
    *   运行**所有**相关的测试（单元测试、集成测试），确保修复没有破坏其他功能（引入副作用）。
    *   手动测试与修复相关的边缘情况和主要用户场景。

## 5. 预防与学习 (Prevention & Learning)

**目标:** 从 Bug 中吸取教训，改进代码和流程，减少未来出现类似问题的概率。

*   **5.1. 代码改进 (Code Improvement):**
    *   思考是否可以通过重构使代码更清晰、更简单、更不易出错（例如，改进变量命名、拆分复杂函数、增加类型提示、添加防御性编程检查）。
*   **5.2. 增加测试覆盖 (Enhance Test Coverage):**
    *   除了回归测试，考虑是否需要为相关模块添加更多不同场景的测试用例，特别是针对边界条件和错误处理。
*   **5.3. 文档记录 (Documentation):**
    *   如果 Bug 的原因或修复方法比较复杂或不直观，在代码注释、Commit Message 或项目文档/知识库中记录下来。
*   **5.4. 知识分享 (Knowledge Sharing):**
    *   与团队成员分享遇到的 Bug 及其解决方案，特别是当它涉及到通用模块、复杂逻辑或第三方库的坑时，可以帮助他人避免重蹈覆辙。



